from __future__ import print_function    # (at top of module)
import click
from . import utils,geo
import geopandas as gpd
import warnings



@click.command()
@click.option("--rivers", required=True, help="Shapefile containing the river Lines...")
@click.option("--profiles", required=True, default=None,help="Shapefile with points or lines that you want as a profiles")
@click.option("--dem", required=True, help="DEM file of the area (cellsize depends on desired accuracy!)")
@click.option("--interpolation_density", default=1,help="Desired distance between points in the profile in [m]!")
@click.option("--profile_density", default=500,help="Desired distance between profiles on the river in [m]!")
@click.option("--profile_width", default=100,help="Desired width of autogenerated the profile [m]!")
@click.option("--chainaging_direction", default="downstream", type=click.Choice(["downstream", "upstream"]), help="Optional argument: semicolon separated manual parameters, required for each transformation method (24regions:4params, triangle:6params,...")
@click.option("--profile_orientation", default="left", type=click.Choice(["left", "right"]), help="Optional argument: semicolon separated manual parameters, required for each transformation method (24regions:4params, triangle:6params,...")
@click.option("--profile_id_f", default=None, help="Field name of the point shapefile, specifying profile id or names")
@click.option("--z_f", default=None, help="Field name of the point shapefile, specifying measured height.")
@click.option("--name_f", help="Arbitrary field containng river names for a river shapefile!")
@click.option("--xns11_out",  default="", help="Optional: name of the XNS11 Mike by DHI inport text file ...")
@click.option("--lines_out", default="", help="Optional: name of the LineString output shapefile,...")
@click.option("--points_out",  default="", help="Optional: name of the Points output shapefile,...")
def cli(river,profiles,dem,
        interpolation_density,
        profile_density,
        profile_width,
        chainaging_direction,
        profile_orientation,
        profile_id_f,
        z_f,
        name_f,
        xns11_out,
        lines_out,
        points_out):

    RIVER_DIRECTION = "downstream"


    if xns11_out == points_out == lines_out == "":
        raise IOError("You haven't specifies any of the output files (--xns11_out,--points_out,--lines_out). "
                      "There is no point in running the program if no results will be stored!")

    # Perform a coordinate system consistency
    EPSG = utils.check_epsg_equality(rasters=[dem], vectors=[river, profiles])

    #Error check rivers!
    if name_f == None:
        raise IOError("You have to specify a column containing river names of the shapefile with the option --name_f!")


    # Create a Rivers object and set a river direction
    rivers = geo.Rivers(df=river, name_f=name_f)
    rivers.set_river_direction(dem_file=dem, direction=RIVER_DIRECTION)


    # Create a XSections Object (You need to specify what rivers will it lay on and which properties will it have
    xsections = geo.Cross_sections(df_r=rivers,
                                   profile_orientation=profile_orientation,
                                   chainaging_direction=chainaging_direction,
                                   naming_direction=chainaging_direction)

    #Read the type of profile type. If No --profiles, then autogenerate, if points, create from points, if lines, create from lines
    if profiles == None:
        warnings.warn("You haven't specified a shapefile as a --profiles option. This means that they are going to be"
                      "generated automatically along the river with the default creation paramaters --interpolation_density=1,"
                      "--profile_density=500,--profile_width=100, which of course you can modify!")

        #Autocreate profiles based on specified settings
        xsections.populate_automatically(profile_density=profile_density,profile_width=profile_width,interpolation_density=interpolation_density)

    else:
        if not profiles.endswith(".shp"):
            raise IOError("--profiles argument can only be ESRI Shapefile!")

        profile_type = gpd.read_file(profiles).ix[0,"geometry"].geom_type
        if profile_type == "Point":
            if profile_id_f == None or z_f == None:
                raise IOError("When having a measurements shapefile as a --profile, one must specify a name of a profile id column"
                              "(--profile_id_f) so the program can know which points to group into a profile, and a name "
                              "of a height column (--z_f)!")

            # Populate xs data from line_shp (it will perform all calculations while initializing already...)
            xsections.populate_from_point_shp(df=profiles, profile_id_f=profile_id_f, z_f=z_f)

        elif profile_type == "LineString":
            # Populate xs data from line_shp (it will perform all calculations while initializing already...)
            xsections.populate_from_line_shp(df_l=profiles, profile_id_f=profile_id_f)

        else:
            raise IOError("--profiles shapefile can only be of a type Point or LineString!")



    # Calculate internal xz chainages per profile (for xns11_file)
    xsections.calculate_internal_xz_chainages()

    ###########
    # RESULTS #
    ###########

    if xns11_out:
        # Export a XNS_file
        xsections.export_to_xns11_file(xns11_file=xns11_out)

    if points_out:
        # Export Points to a shapefile
        geo.Shp.save_to_shapefile_with_prj(geo_df=xsections.df, file_out=points_out, epsg=EPSG)

    if lines_out:
        # Export XS Lines to a shapefile
        geo.Shp.save_to_shapefile_with_prj(geo_df=xsections.df_l, file_out=lines_out, epsg=EPSG)





###############



print("You have decided to run script interactively through the command line interface.\n"
      "If you know what you are doing, you can run script by specifying inputs in the inputs.py file and then running "
      "the script by 'python lib.py inputs'."
      "Make sure you have read the manual in README file and you understand the meaning and options of the inputs you are going to specify!")
print("")

# todo: write rules oz link!
# EPSG CHECK!
# POINT CHECK!
# NE ZAHTEVAJ POINT_IDja. Se da?

while True:
    CREATION_METHOD = input(
        "1. Specify the desired profile creation method! Possible options: [auto/lines/measurements] : ").lower()
    if CREATION_METHOD not in ["auto", "lines", "measurements"]:
        logger.warn("{} is not a valid creation method! See the instructions!".format(CREATION_METHOD))
    else:
        print("Selected CREATION_METHOD: {}\n".format(CREATION_METHOD))
        break

while True:
    RIVER_SHP = input("2.1. Specify the location of the shapefile (*.shp!), representing your river branches:")
    if not os.path.isfile(RIVER_SHP):
        logger.warn(
            "I can't find a shapefile {}. Make sure the file exists and is within the script's visible scope!".format(
                RIVER_SHP))
    elif not RIVER_SHP.endswith(".shp"):
        logger.warn("Specified file doesn't have the extension *.shp! It must be a shapefile!")
    else:
        river_shp_fields = gpd.read_file(RIVER_SHP).columns.tolist()
        print("Selected RIVER_SHP: {}\n".format(RIVER_SHP))
        break

while True:
    RIVERNAME_FIELD = input("2.2. Specify the column name, containing the names of the rivers in river shapefiles!")
    if RIVERNAME_FIELD not in river_shp_fields:
        logger.warn("Specifed river shapefile doesn't have any column with a name {}. Pick one from the following:\n"
                    "{}".format(RIVERNAME_FIELD, ",".join(river_shp_fields)))
    else:
        print("Selected RIVERNAME_FIELD: {}\n".format(RIVERNAME_FIELD))
        break

while True:
    RIVER_DIRECTION = input(
        "2.3. Specify the desired river orientation for the chainaging purposes. Defaults to downstream.").lower() or "downstream"
    if RIVER_DIRECTION not in ["upstream", "downstream"]:
        logger.warn(
            "{} is not a valid river direction/orientation!  This switch can only be upstream or downstream!".format(
                RIVER_DIRECTION))

    else:
        print("Selected RIVER_DIRECTION: {}\n".format(RIVER_DIRECTION))
        break

while True:
    DEM_FILE = input(
        "3. Specify a .tiff DEM file covering the desired area! It is neccessary for the river directioning!")
    if not os.path.isfile(DEM_FILE):
        logger.warn("I can't find a dem {}. Make sure the file exists and is within the script's visible scope!")
    elif DEM_FILE.split(".")[-1].lower() not in ["tiff", "tif"]:
        print(DEM_FILE)
        print(DEM_FILE.split(".")[-1].lower())
        logger.warn("Specified file doesn't have the extension *.tif! It must be a tiff raster!")
    else:
        print("Selected DEM_FILE: {}\n".format(DEM_FILE))
        break

while True:
    XSECTION_ORIENTATION = input("4.1. Specify the desired profile orientation. Defaults to left: ").lower() or "left"
    if XSECTION_ORIENTATION not in ["left", "right"]:
        logger.warn("{} is not a valid profile orientation! This switch can only be left or right!".format(
            XSECTION_ORIENTATION))
    else:
        print("Selected XSECTION_ORIENTATION: {}\n".format(XSECTION_ORIENTATION))
        break

if CREATION_METHOD == "auto":
    while True:
        INTERPOLATION_DENSITY = input(
            "4.2. Specify the desired interpolation density within profile [in meters]. Defaults to 1m: ") or 1
        try:
            INTERPOLATION_DENSITY = int(INTERPOLATION_DENSITY)
            print("Selected INTERPOLATION_DENSITY: {}\n".format(INTERPOLATION_DENSITY))
            break
        except:
            logger.warn("Interpolation density must be an integer!")

    while True:
        PROFILE_WIDTH = input(
            "4.3. Specify the desired width of the autogenerated profiles [in meters]. Defaults to 100m: ") or 100
        try:
            PROFILE_WIDTH = int(PROFILE_WIDTH)
            print("Selected PROFILE_WIDTH: {}\n".format(PROFILE_WIDTH))
            break
        except:
            logger.warn("Profile width size must be an integer!")

    while True:
        PROFILE_DENSITY = input(
            "4.4. Specify the desired distance between the autogenerated profiles [in meters]. Defaults to 200m: ") or 200
        try:
            PROFILE_DENSITY = int(PROFILE_DENSITY)
            print("Selected PROFILE DENSITY: {}\n".format(PROFILE_DENSITY))
            break
        except:
            logger.warn("Profile density must be an integer!")

    while True:
        NAMING_DIRECTION = input(
            "4.4. Specify the desired distance between the autogenerated profiles [in meters]. Defaults to 200m: ") or 200
        try:
            NAMING_DIRECTION = int(NAMING_DIRECTION)
            print("Selected NAMING_DIRECTION: {}\n".format(NAMING_DIRECTION))
            break
        except:
            logger.warn("Profile density must be an integer!")


elif CREATION_METHOD == "measurements":
    while True:
        XSECTION_SHP = input(
            "4.2. Specify the location of the Point shapefile (*.shp!), representing locations of the profile measurements:")
        if not os.path.isfile(XSECTION_SHP):
            logger.warn(
                "I can't find a shapefile {}. Make sure the file exists and is within the script's visible scope!")
        elif not XSECTION_SHP.endswith(".shp"):
            logger.warn("Specified file doesn't have the extension *.shp! It must be a shapefile!")
        else:
            xsections_shp_fields = gpd.read_file(XSECTION_SHP).columns.tolist()
            print("Selected XSECTION_SHP: {}\n".format(XSECTION_SHP))
            break

    while True:
        XSECTION_PROFILE_ID_FIELD = input(
            "4.3. Specify the column name, containing the names of the profiles in cross section shapefiles!\n"
            "If omitted, profile ids with be autogenerated!")
        if XSECTION_PROFILE_ID_FIELD not in xsections_shp_fields:
            logger.warn(
                "Specifed xsections shapefile doesn't have any column with a name {}. Pick one from the following:\n"
                "{}".format(XSECTION_PROFILE_ID_FIELD, ",".join(xsections_shp_fields)))
        else:
            print("Selected XSECTION_PROFILE_ID_FIELD: {}\n".format(XSECTION_PROFILE_ID_FIELD))
            break

    while True:
        XSECTION_POINT_ID_FIELD = input(
            "2.2. Specify the column name, containing the consecutive number of the points within the same profile!")
        if XSECTION_POINT_ID_FIELD not in xsections_shp_fields:
            if XSECTION_PROFILE_ID_FIELD not in xsections_shp_fields:
                logger.warn(
                    "Specifed xsections shapefile doesn't have any column with a name {}. Pick one from the following:\n"
                    "{}".format(XSECTION_PROFILE_ID_FIELD, ",".join(xsections_shp_fields)))
        else:
            print("Selected XSECTION_POINT_ID_FIELD: {}\n".format(XSECTION_POINT_ID_FIELD))
            break

    while True:
        Z_FIELD = input("2.2. Specify the column name, containing the height of the measured point!")
        if Z_FIELD not in xsections_shp_fields:
            if Z_FIELD not in xsections_shp_fields:
                logger.warn(
                    "Specifed xsections shapefile doesn't have any column with a name {}. Pick one from the following:\n"
                    "{}".format(Z_FIELD, ",".join(xsections_shp_fields)))
        else:
            print("Selected Z_FIELD: {}\n".format(Z_FIELD))
            break

elif CREATION_METHOD == "lines":
    while True:
        XSECTION_SHP = input(
            "4.2. Specify the location of the LineString shapefile (*.shp!), representing locations of desired cross sections:")
        if not os.path.isfile(XSECTION_SHP):
            logger.warn(
                "I can't find a shapefile {}. Make sure the file exists and is within the script's visible scope!".format(
                    XSECTION_SHP))
        elif not XSECTION_SHP.endswith(".shp"):
            logger.warn("Specified file doesn't have the extension *.shp! It must be a shapefile!")
        else:
            xsections_shp_fields = gpd.read_file(XSECTION_SHP).columns.tolist()
            print("Selected XSECTION_SHP: {}\n".format(XSECTION_SHP))
            break

while True:
    XNS11_OUT = input(
        "5.1. Specify the absolute path of the Mike 11 XNS import cross section_file! (defaults to xns11_ready.txt") or "Mike11_xns_ready.txt"
    if not XNS11_OUT.lower().endswith("txt"):
        logger.warn("WARNING! Mike XNS11 output file must be a .txt file!")
    else:
        print("Selected XNS11_OUT file: {}\n".format(XNS11_OUT))
        break

while True:
    POINTS_OUT = input(
        "5.2. Specify the absolute path of the result XNS point shapefile if you want it! (defaults to None)") or None
    if POINTS_OUT != None:
        if not POINTS_OUT.lower().endswith("txt"):
            logger.warn("WARNING! Points out file must be an ESRI .shp file!")
    else:
        print("Selected POINTS_OUT file: {}\n".format(POINTS_OUT))
        break

while True:
    LINES_OUT = input(
        "5.3. Specify the absolute path of the result XNS lines shapefile if you want it! (defaults to None)") or None
    if LINES_OUT != None:
        if not LINES_OUT.lower().endswith("txt"):
            logger.warn("WARNING! Lines output file must be a ESRI .shp file!")
    else:
        print("Selected LINES_OUT file: {}\n".format(LINES_OUT))
        break
